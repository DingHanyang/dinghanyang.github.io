

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo/fire_logo.png">
  <link rel="icon" href="/img/logo/fire_logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Hanyang Ding">
  <meta name="keywords" content="">
  
    <meta name="description" content="CPython的内存管理首先我们设想下，CPython是由C语言实现的，为什么他不直接使用C语言中的malloc系列函数，而要自己折腾一个内存管理呢？ 在C中，有三种内存分配方式：  静态内存分配（static memory allocation），编译期间即可计算所需分配内存大小，在可执行文件开始运行时分配。 自动内存分配（automatic memory allocation），当一个帧开始运">
<meta property="og:type" content="article">
<meta property="og:title" content="CPython(2) - 内存管理与垃圾回收">
<meta property="og:url" content="https://dinghanyang.github.io/dhy_blog/2024/10/13/cpython-memory/index.html">
<meta property="og:site_name" content="蜜蜂和鱼">
<meta property="og:description" content="CPython的内存管理首先我们设想下，CPython是由C语言实现的，为什么他不直接使用C语言中的malloc系列函数，而要自己折腾一个内存管理呢？ 在C中，有三种内存分配方式：  静态内存分配（static memory allocation），编译期间即可计算所需分配内存大小，在可执行文件开始运行时分配。 自动内存分配（automatic memory allocation），当一个帧开始运">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dinghanyang.github.io/2024/10/13/">
<meta property="og:image" content="https://dinghanyang.github.io/img/cpython-memory/%E5%86%85%E5%AD%98%E6%B1%A0%E8%A1%A8%E7%A4%BA.png">
<meta property="og:image" content="https://dinghanyang.github.io/2024/10/13/cpython-memory/gc_generation%20(1).png">
<meta property="og:image" content="https://dinghanyang.github.io/2024/10/13/cpython-memory/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png">
<meta property="og:image" content="https://dinghanyang.github.io/2024/10/13/cpython-memory/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A82%20(2).png">
<meta property="article:published_time" content="2024-10-13T06:27:38.000Z">
<meta property="article:modified_time" content="2024-11-09T09:22:07.373Z">
<meta property="article:author" content="Hanyang Ding">
<meta property="article:tag" content="CPython">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://dinghanyang.github.io/2024/10/13/">
  
  
  
  <title>CPython(2) - 内存管理与垃圾回收 - 蜜蜂和鱼</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"dinghanyang.github.io","root":"/","version":"1.9.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"gtag":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>DingHanyang</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CPython(2) - 内存管理与垃圾回收"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-10-13 14:27" pubdate>
          2024年10月13日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          4.5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          38 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CPython(2) - 内存管理与垃圾回收</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="CPython的内存管理"><a href="#CPython的内存管理" class="headerlink" title="CPython的内存管理"></a>CPython的内存管理</h2><p>首先我们设想下，CPython是由C语言实现的，为什么他不直接使用C语言中的malloc系列函数，而要自己折腾一个内存管理呢？</p>
<p>在C中，有三种内存分配方式：</p>
<ul>
<li>静态内存分配（static memory allocation），编译期间即可计算所需分配内存大小，在可执行文件开始运行时分配。</li>
<li>自动内存分配（automatic memory allocation），当一个帧开始运行的时候，操作系统会在调用栈中为此作用域分配所需内存，当帧执行完成后，这部分内存会被释放。</li>
<li>动态内存分配（dynamic memory allocation），可以通过调用内存分配API在运行时动态地请求和分配内存。</li>
</ul>
<p>考虑这个程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the size of the array: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-comment">// Dynamically allocate memory for the array</span><br>    <span class="hljs-type">int</span> *<span class="hljs-built_in">array</span> = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-comment">// Free the allocated memory</span><br>    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">array</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述程序运行时，系统并不清楚需要分配具体多大的内存，直到接收到用户输入后，通过C API动态分配内存。<br>由于Python是一门动态类型的语言，大多数内建类型大小都是可以动态调整的，比如<code>List</code>可以是任意长度，<code>Dict</code>键的数量可以动态变化，所以<strong>动态内存分配</strong>在Python中显得尤为重要。<br>而频繁的进行内存的分配与释放会严重影响程序的效率，并且可能造成大量的<strong>内存碎片</strong>。为了解决这些问题，Python自己设计了一套内存管理方案，包含了<strong>内存池、引用计数法、垃圾回收算法等</strong>内容。</p>
<h3 id="CPython的内存分配域"><a href="#CPython的内存分配域" class="headerlink" title="CPython的内存分配域"></a>CPython的内存分配域</h3><ul>
<li>Raw Domain 原始内存分配域：用于从系统堆上分配内存，作用于大块或非对象的内存分配。</li>
<li>Object Domain 对象内存分配域：用于所有Python对象的内存分配。</li>
<li>Mem Domain PyMem 内存分配域：和PYMEM_DOMAIN_OBJ对象功能一致，用于支持旧版本API。</li>
</ul>
<h3 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h3><p>CPython使用两种内存分配器：</p>
<ul>
<li>malloc，操作系统层面的内存分配器，主要用于原始内存的分配。</li>
<li>pymalloc，CPython层面的内存分配器，用于PyMem内存分配域和对象内存分配域。</li>
</ul>
<p>由于Python中大部分需要分配的内存都是碎片化且是固定大小的，比如<code>PyObject</code>占16字节、<code>PyLongObject</code>占32字节。在这种情况下，内存碎片的产生概率是非常大的，所以CPython设计将需要分配的内存按大小进行统一管理。其中：</p>
<ul>
<li>对象大于等于256KB，将会由系统内存分配管理。</li>
<li>对象小于256KB，将会由pymalloc进行分配。</li>
</ul>
<h3 id="内存块、内存池与堆区"><a href="#内存块、内存池与堆区" class="headerlink" title="内存块、内存池与堆区"></a>内存块、内存池与堆区</h3><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>堆区是最大的可分配内存单元。系统页的边界是固定长度的连续内存块，为了与系统页的大小对齐，CPython中创建的堆区大小固定为256KB。</p>
<img src="/2024/10/13/cpython-memory/.." srcset="/img/loading.gif" lazyload  alt="堆区表示" style="zoom:80%;" />

<p>与堆区对应的是<strong>arena_object</strong></p>
<h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p>在堆区中，我们可以为最大为512字节的内存块创建内存池。每个内存池的大小为4096字节，也就是4K，一个堆区中总是存在64个内存池。</p>
<p><img src="/./../img/cpython-memory/%E5%86%85%E5%AD%98%E6%B1%A0%E8%A1%A8%E7%A4%BA.png" srcset="/img/loading.gif" lazyload alt="内存池表示"><br>根据32位系统和64位系统的不同，内存块的步长也不同，对于32位系统，步长为8字节，总共有64种不同的内存块。</p>
<table>
<thead>
<tr>
<th align="center">以字节为单位请求申请内存</th>
<th align="center">分配内存块的大小</th>
<th align="center">内存大小索引</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1-8</td>
<td align="center">8</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">9-16</td>
<td align="center">16</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">505-512</td>
<td align="center">512</td>
<td align="center">63</td>
</tr>
</tbody></table>
<p>以32位系统为例，只要请求的内存大小不超过 <em>8</em> 字节，<em>Python</em> 都在这个内存池为其分配一块 <em>8</em> 字节内存，就算只申请 1 字节内存也是如此。这种做法好处显而易见，内存起始地址均以计算机字为单位对齐。计算机以 <strong>字</strong> ( <em>word</em> ) 为单位访问内存，因此内存以字对齐可提升内存读写速度。<br>CPython会根据内存请求的大小分配内存池，当没有可以用的内存池用于请求的内存大小索引时，就可以分配一个新的内存池。堆区中有一个概念叫<strong>高水位线</strong>，可以用于查询当前已经分配的内存池数量。内存池存在三种状态：</p>
<ul>
<li><strong>满载</strong>，所有可用内存块均已被分配，可以暂时不管。</li>
<li><strong>部分使用</strong>，已经有部分内存被分配，但还存在空闲内存，会以双向链表的方式组织起来。</li>
<li><strong>空闲</strong>，内存池被分配，但内存池中的内存块均未被使用，待使用或归还。</li>
</ul>
<p>三种状态决定了CPython对其的管理方式。</p>
<p>[^A1]: 在创建堆（arena）时，CPython并不会一次性为所有大小类别的内存池都分配内存，而是根据实际需求逐步进行分配。例如，当需要一个 32 字节大小的对象时，Python会检查是否有合适的内存池，如果没有则创建一个用于存储 32 字节大小的内存块的内存池。另外，虽然每个内存池的总大小固定为4 KB，但因为每个池中内存块的大小不同，导致每个内存池内包含的内存块数量是不同的。</p>
<h4 id="内存池表"><a href="#内存池表" class="headerlink" title="内存池表"></a>内存池表</h4><p>在堆区中，内存池的存储单元名为<strong>内存池表</strong>，pool table记录了被部分使用的内存池的双向链表头节点。内存池表根据内存池的内存大小索引<code>i</code>进行分类。对于内存大小索引<code>i</code>，<code>usedpools[i + 1]</code>会指向所有被部分使用的内存池的双向链表头节点，链表中的内存池都拥有相同的类型大小。</p>
<ul>
<li>当一个内存池饱和后，它就会被<code>usedpools[]</code>解除链接。</li>
<li>如果已经饱和的内存池中有一个内存块被释放了，那么内存池就将重新回到部分使用的状态。此时还会帮刚刚释放内存的内存池重新连接到<code>usepools[]</code>中链表的前面，这样在下次分配同样大小的内存时将复用刚刚释放的内存块。</li>
<li>当一个内存池变为全空时，这个内存池同样也会从<code>usedpools[]</code>中被移除，然后被链接到它所在的堆区的单向链表的<code>freepools</code>的前面。</li>
</ul>
<h4 id="内存块"><a href="#内存块" class="headerlink" title="内存块"></a>内存块</h4><p>内存块也是同样的，在一个内存池中有存在多个内存块，数量根据内存块的大小而有所不同，比如一个管理8字节的内存池中存在4096&#x2F;8 &#x3D; 512个内存块。而管理512字节内存块的内存池中仅有8个内存块。</p>
<ul>
<li>在一个内存池中，可以分配和释放固定内存大小索引的内存块。</li>
<li>所有可用的内存块都会被链接到<code>freeblock</code>链表上。</li>
<li>当一个内存块被释放后，他会被插入到<code>freeblock</code>的头部。</li>
<li>当一个内存池被初始化时，只有最前面两个内存块会被链接到<code>freeblock</code>，因为接收到申请，才初始化内存池，并不存在创建内存池等分配的情况，并且下一个内存块的地址可以通过上一个内存块计算出来。</li>
<li>如果一个内存池处于被部分使用的状态，那么这个内存池里面至少有一个内存块用于内存分配。</li>
</ul>
<h2 id="CPython的垃圾内收"><a href="#CPython的垃圾内收" class="headerlink" title="CPython的垃圾内收"></a>CPython的垃圾内收</h2><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数真的是最简单及常见的垃圾回收方法之一了。CPython通过维护内部对象的引用次数，将没有被引用的对象回收以释放内存。每一个PyObject实例对象都有一个<code>ob_refcnt</code>属性来记录引用数量，且CPython通过<code>Py_INCREF</code>和<code>Py_DECREF</code>来控制引用计数属性的增减。在<code>Include/object.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> _Py_INCREF(PyObject *op)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> Py_REF_DEBUG</span><br>    _Py_RefTotal++;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    op-&gt;ob_refcnt++;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Py_INCREF(op) _Py_INCREF(_PyObject_CAST(op))</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> _Py_DECREF(<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> Py_REF_DEBUG</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> lineno,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    PyObject *op)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> Py_REF_DEBUG</span><br>    _Py_RefTotal--;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (--op-&gt;ob_refcnt != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> Py_REF_DEBUG</span><br>        <span class="hljs-keyword">if</span> (op-&gt;ob_refcnt &lt; <span class="hljs-number">0</span>) &#123;<br>            _Py_NegativeRefcount(filename, lineno, op);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        _Py_Dealloc(op);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>Py_INCREF</code>的定义是简单的，只需控制引用计数属性的自增，<code>Py_DECREF</code>还需要处理当引用计数为0后的触发析构函数的操作。<br>一般来说Python的开发者几乎无法控制引用计数的操作，因为他都发生在CPython字节码中。但是引用计数最大的问题是会产生循环引用，比如在Python代码中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = []<br>a.append(a)<br><span class="hljs-keyword">del</span> a<br></code></pre></td></tr></table></figure>

<p>此时由于a引用了自己，所以即使在del操作后，a的引用计数也会为1。为了解决此类问题，Python还引入了垃圾回收。</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>由于Python中充斥着大量的容器类型，如列表、元组、字典、集合等，在开发者的操作下很容易造成循环引用且生成大量<strong>不可达对象</strong>而垃圾回收算法的主要目的就是找到这些不可达对象且将他们回收。对于长期运行的程序来说，这是非常重要的一个操作。垃圾回收器只会查找在类型定义中设置了<code>Py_TPFLAGS_HAVE_GC</code>标志的类型。以下是在Python3.9.12中被标记为需要垃圾回收的类型：</p>
<ul>
<li>类、方法、函数对象</li>
<li>cell对象</li>
<li>字节数组、单字节、Unicode字符串</li>
<li>字典</li>
<li>属性中的描述符对象</li>
<li>枚举对象</li>
<li>异常</li>
<li>帧对象</li>
<li>列表、元组、命名元组和集合</li>
<li>内存对象</li>
<li>模块和命名空间</li>
<li>类型和弱引用对象</li>
<li>迭代器和生成器</li>
<li>pickle缓存区</li>
</ul>
<p>诸如浮点数类型、整型、布尔类型、NoneType都不会被标记。当然如果自己编写Python的C语言拓展模块，也可以按需增加标记，从而使得CPython的垃圾回收机制能够追踪。</p>
<p>其中垃圾回收机制还创造了一种取消追踪的机制，由于元组是不可变对象，所以他一旦被创建，就不会改变，但是元组中可以包含可变类型。所以当垃圾回收器运行的时候，每一个元组都会检查自己是否只包含不可变（或者不需要追踪）对象，如果只包含不可变对象的话，元组就会申请取消对自己的追踪，从而减少垃圾回收器的开销。</p>
<p>当我们创建空字典时，他虽然是可变对象，但是在未往其中添加数据时，垃圾回收器并不会追踪他们，可以通过<code>gc</code>模块中的gc.is_tracked(obj)来查看一个对象是否被追踪。</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">import</span> <span class="hljs-variable">gc</span><br><span class="hljs-variable">a</span> = <span class="hljs-function"><span class="hljs-title">dict</span>()</span><br><span class="hljs-variable">gc.is_tracked</span>(<span class="hljs-variable">a</span>)<br>&gt;&gt;&gt;<span class="hljs-variable"><span class="hljs-literal">False</span></span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]</p>
<p><a target="_blank" rel="noopener" href="https://github.com/python/cpython/issues/48324">https://github.com/python/cpython/issues/48324</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/python/cpython/issues/48938">https://github.com/python/cpython/issues/48938</a></p>
<p>2008年，为了解决创造a list of tuples中大量空元组使得gc性能下降明显而做的优化。</p>
<p>此处有一个较为疑惑的点是，为什么在Python3.1中，减少了对新建的空字典的GC追踪而不取消对新建的空列表的追踪呢？当然字典这个结构在Python层面是非常重要的，对性能的影响也是巨大，但这不意味改变对新建空List的追踪不会带来性能上的提升，挖个坑补全下这个的历史原因及相关的实验。</p>
</blockquote>
<h5 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h5><p><em>Python</em> 程序启动后，内部可能会创建大量对象。如果每次执行标记清除法时，都需要遍历所有对象，多半会影响程序性能。为此，<em>Python</em> 引入分代回收机制——将对象分为若干“<strong>代</strong>”( <em>generation</em> )，每次只处理某个代中的对象，因此 <em>GC</em> 卡顿时间更短。</p>
<p>考察对象的生命周期，可以发现一个显著特征：一个对象存活的时间越长，它下一刻被释放的概率就越低。我们应该也有这样的亲身体会：经常在程序中创建一些临时对象，用完即刻释放；而定义为全局变量的对象则极少释放。</p>
<p>因此，根据对象存活时间，对它们进行划分就是一个不错的选择。对象存活时间越长，它们被释放的概率越低，可以适当降低回收频率；相反，对象存活时间越短，它们被释放的概率越高，可以适当提高回收频率。</p>
<table>
<thead>
<tr>
<th align="center">对象存活的时间</th>
<th>释放的概率</th>
<th align="center">GC检查的频率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">长</td>
<td>低</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">短</td>
<td>高</td>
<td align="center">高</td>
</tr>
</tbody></table>
<p><em>Python</em> 内部根据对象存活时间，将对象分为 <em>3</em> 代。</p>
<p>每个代都由一个 <em>gc_generation</em> 结构体来维护，定义于 <em>Include&#x2F;internal&#x2F;pycore_gc.h</em> 头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gc_generation</span> &#123;</span><br>    PyGC_Head head;<br>    <span class="hljs-type">int</span> threshold; <span class="hljs-comment">/* collection threshold */</span><br>    <span class="hljs-type">int</span> count; <span class="hljs-comment">/* count of allocations or collections of younger</span><br><span class="hljs-comment">                  generations */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>head ，可收集对象链表头部，代中的对象通过该链表维护；</li>
<li>threshold ，仅当 <em>count</em> 超过本阀值时，<em>Python</em> 垃圾回收操作才会扫描本代对象；</li>
<li>count ，计数器，不同代统计项目不一样；</li>
</ul>
<p>每个 <em>gc_generation</em> 结构体链表头节点都指向自己，换句话说每个可收集对象链表一开始都是空的；计数器字段 <em>count</em> 都被初始化为 <em>0</em> ；而阀值字段 <em>threshold</em> 则有各自的策略。</p>
<img src="/2024/10/13/cpython-memory/gc_generation (1).png" srcset="/img/loading.gif" lazyload  alt="gc_generation (1)" style="zoom:67%;" />

<p><em>Python</em> 调用 <em>_PyObject_GC_Alloc</em> 为需要跟踪的对象分配内存时，该函数将初生代 <em>count</em> 计数器加一，随后对象将接入初生代对象链表；当 <em>Python</em> 调用 <em>PyObject_GC_Del</em> 释放垃圾对象内存时，该函数将初生代 <em>count</em> 计数器减一；*_PyObject_GC_Alloc* 自增 <em>count</em> 后如果超过阀值( <em>700</em> )，将调用 <em>collect_generations</em> 执行一次垃圾回收( <em>GC</em> )。</p>
<p><em>collect_generations</em> 函数从老生代开始，逐个遍历每个生代，找出需要执行回收操作( <em>count&gt;threshold</em> )的最老生代。随后调用 <em>collect_with_callback</em> 函数开始回收该生代，而该函数最终调用 <em>collect</em> 函数。</p>
<p><em>collect</em> 函数处理某个生代时，先将比它年轻的生代计数器 count 重置为 <em>0</em> ；然后将它们的对象链表移除，与自己的拼接在一起后执行 <em>GC</em> 算法；最后，将下一个生代计数器加一。</p>
<ul>
<li>系统每新增 <em>701</em> 个需要 <em>GC</em> 的对象，<em>Python</em> 就执行一次 <em>GC</em> 操作；</li>
<li>每次 <em>GC</em> 操作需要处理的生代可能是不同的，由 <em>count</em> 和 <em>threshold</em> 共同决定；</li>
<li>某个生代需要执行 <em>GC</em> ( <em>count&gt;threshold</em> )，在它前面的所有年轻生代也同时执行 <em>GC</em> ；</li>
<li>对多个代执行 <em>GC</em> ，<em>Python</em> 将它们的对象链表拼接在一起，一次性处理；</li>
<li><em>GC</em> 执行完毕后，<em>count</em> 清零，而后一个生代 <em>count</em> 加一；</li>
</ul>
<p>初生代触发 <em>GC</em> 操作，<em>Python</em> 执行 <em>collect_generations</em> 函数。它找出了达到阀值的最老生代是中生代，因此调用 <em>collection_with_callback(1)</em> ，<em>1</em> 是中生代在数组中的下标。</p>
<p><em>collection_with_callback(1)</em> 最终执调用 <em>collect(1)</em> ，它先将后一个生代计数器加一；然后将本生代以及前面所有年轻生代计数器重置为零；最后调用 <em>gc_list_merge</em> 把可回收对象链表合并在一起。</p>
<ul>
<li>每新增 <em>701</em> 个需要 <em>GC</em> 的对象，触发一次新生代 <em>GC</em> ；</li>
<li>每执行 <em>11</em> 次新生代 <em>GC</em> ，触发一次中生代 <em>GC</em> ；</li>
<li>每执行 <em>11</em> 次中生代 <em>GC</em> ，触发一次老生代 <em>GC</em> (老生代 <em>GC</em> 还受其他策略影响，频率更低)；</li>
<li>执行某个生代 <em>GC</em> 前，年轻生代对象链表也移入该代，一起 <em>GC</em> ；</li>
<li>一个对象创建后，随着时间推移将被逐步移入老生代，回收频率逐渐降低；</li>
</ul>
<h5 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h5><p><em>Python</em> 采用标记清除法识别垃圾对象。该算法的输入是可收集对象链表，链表给出所有需要检测的对象；算法的输出是两个链表，其中一个包含 <strong>可达</strong> ( <em>reachable</em> )对象，另一个包含 <strong>不可达</strong> ( <em>unreachable</em> )对象。</p>
<p>标记清除算法在 <em>collect</em> 函数中实现，它位于 <em>Modules&#x2F;gcmodule.c</em> ，步骤并不复杂。为避免深陷源码细节，我们先抽出身来进行一次直观考察。假设待检测可收集对象链表中的对象引用关系如下：</p>
<img src="/2024/10/13/cpython-memory/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" srcset="/img/loading.gif" lazyload class="" title="循环引用">

<p>其中，数字表示引用计数，箭头表示引用关系，虚线表示链表外对象(来自其他年代)，</p>
<p>首先，我们需要找出根对象。这里根对象是指被本链表以外的对象引用或被 <em>Python</em> 虚拟机直接引用的对象，与上一小节讨论的略有不同。由于根对象存在来自外部的引用，不能安全释放，应该标记为 <strong>可达</strong> ( <em>reachable</em> )。</p>
<p>根对象集合不难确定：我们只需遍历每个对象引用的对象，将它们的引用计数减一，最后计数不为零的就是根对象。</p>
<img src="/2024/10/13/cpython-memory/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A82%20(2).png" srcset="/img/loading.gif" lazyload class="" title="循环引用2 (2)">

<p>请注意，虚线表示外部对象，它既不会被遍历到，引用计数也不会被减一。然后从根节点对象出发，将所有不可达的节点标记为不可达节点，如最左边图中的三个对象均为不可达对象。这样一来，他们就是只存在循环引用的垃圾对象，可以被安全释放。</p>
<p>对于<em>collect</em> 函数的算法处理逻辑，它先将对象引用计数拷贝到 <em>gc_refs</em> 字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">update_refs(young);<br></code></pre></td></tr></table></figure>

<p>这是因为直接操作 <em>ob_refcnt</em> 字段的话，对象的引用计数就被破坏了，而且无法复原。操作 <em>gc_refs</em> 副本字段，就不存在这个问题。</p>
<p>接着，<em>collect</em> 函数调用 <em>subtract_refs</em> 遍历链表中每个对象，将它们引用的对象引用计数( <em>gc_refs</em> )减一。注意到，<em>subtract_refs</em> 函数调用 <em>tp_traverse</em> 函数，来遍历被一个对象引用的对象：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">subtract_refs</span>(young);<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">visit_decref</span><span class="hljs-params">(PyObject *op, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    assert(op != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (PyObject_IS_GC(op)) &#123;<br>        PyGC_Head *gc = AS_GC(op);<br>        assert(_PyGCHead_REFS(gc) != <span class="hljs-number">0</span>); <span class="hljs-comment">/* else refcount was too small */</span><br>        <span class="hljs-keyword">if</span> (_PyGCHead_REFS(gc) &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 将对象引用计数减一(gc_refs)</span><br>            _PyGCHead_DECREF(gc);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">subtract_refs</span><span class="hljs-params">(PyGC_Head *containers)</span><br>&#123;<br>    traverseproc traverse;<br>    PyGC_Head *gc = containers-&gt;gc.gc_next;<br>    <span class="hljs-comment">// 遍历链表每一个对象</span><br>    <span class="hljs-keyword">for</span> (; gc != containers; gc=gc-&gt;gc.gc_next) &#123;<br>        <span class="hljs-comment">// 遍历当前对象所引用的对象，调用visit_decref将它们的引用计数减一</span><br>        traverse = Py_TYPE(FROM_GC(gc))-&gt;tp_traverse;<br>        (<span class="hljs-type">void</span>) traverse(FROM_GC(gc),<br>                       (visitproc)visit_decref,<br>                       <span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过这个步骤之后，根对象就被找出来了，它们的引用计数( <em>gc_refs</em> )不为零。</p>
<p>最后，<em>collect</em> 函数初始化一个链表 <em>unreachable</em> 来保存不可达对象，调用 <em>move_unreachable</em> 标记可达对象，并将不可达对象移入 <em>unreachable</em> 链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">gc_list_init(&amp;unreachable);<br>move_unreachable(young, &amp;unreachable);<br></code></pre></td></tr></table></figure>

<p><em>move_unreachable</em> 遍历给定对象链表，如果一个对象的引用计数不为 <em>0</em> ，就将它标记为可达( <em>GC_REACHABLE</em> )；否则将它标记为临时不可达，移入不可达链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 遍历链表每个对象</span><br><span class="hljs-keyword">while</span> (gc != young) &#123;<br>    PyGC_Head *next;<br><br>    <span class="hljs-comment">// 如果引用计数不为0，说明它可达</span><br>    <span class="hljs-keyword">if</span> (_PyGCHead_REFS(gc)) &#123;<br>        PyObject *op = FROM_GC(gc);<br>        traverseproc traverse = Py_TYPE(op)-&gt;tp_traverse;<br>        assert(_PyGCHead_REFS(gc) &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将它标记为可达</span><br>        _PyGCHead_SET_REFS(gc, GC_REACHABLE);<br>        <span class="hljs-comment">// 遍历被它引用的对象，调用visit_reachable将被引用对象标记为可达</span><br>        (<span class="hljs-type">void</span>) traverse(op,<br>                        (visitproc)visit_reachable,<br>                        (<span class="hljs-type">void</span> *)young);<br>        next = gc-&gt;gc.gc_next;<br>        <span class="hljs-keyword">if</span> (PyTuple_CheckExact(op)) &#123;<br>            _PyTuple_MaybeUntrack(op);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        next = gc-&gt;gc.gc_next;<br>        <span class="hljs-comment">// 暂时移入不可达链表</span><br>        gc_list_move(gc, unreachable);<br>        _PyGCHead_SET_REFS(gc, GC_TENTATIVELY_UNREACHABLE);<br>    &#125;<br>    gc = next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果一个对象可达，<em>Python</em> 还通过 <em>tp_traverse</em> 逐个遍历它引用的对象，并调用 <em>visit_reachable</em> 函数进行标记：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">visit_reachable</span><span class="hljs-params">(PyObject *op, PyGC_Head *reachable)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (PyObject_IS_GC(op)) &#123;<br>        PyGC_Head *gc = AS_GC(op);<br>        <span class="hljs-type">const</span> Py_ssize_t gc_refs = _PyGCHead_REFS(gc);<br><br>        <span class="hljs-keyword">if</span> (gc_refs == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 引用计数为零，将计数设置为1，表明它是可达的</span><br>            _PyGCHead_SET_REFS(gc, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gc_refs == GC_TENTATIVELY_UNREACHABLE) &#123;<br>            <span class="hljs-comment">// 如果对象被临时标记为不可达，将引用计数设置为1表明它是可达的</span><br>            <span class="hljs-comment">// 并移回原链表继续处理</span><br>            gc_list_move(gc, reachable);<br>            _PyGCHead_SET_REFS(gc, <span class="hljs-number">1</span>);<br>        &#125;<br>         <span class="hljs-keyword">else</span> &#123;<br>            assert(gc_refs &gt; <span class="hljs-number">0</span><br>                   || gc_refs == GC_REACHABLE<br>                   || gc_refs == GC_UNTRACKED);<br>         &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果被引用的对象引用计数为 <em>0</em> ，将它的引用计数设为 <em>1</em> ，之后它将被 <em>move_unreachable</em> 遍历到并设为可达；如果被引用的对象被临时移入 <em>unreachable</em> 链表，同样将它的引用计数设为 <em>1</em> ，并从 <em>unreachable</em> 链表移回原链表尾部，之后它将被 <em>move_unreachable</em> 遍历到并设为可达。</p>
<p>当 <em>move_unreachable</em> 函数执行完毕，<em>unreachable</em> 链表中的对象就是不可达对象，可被安全回收。</p>
<p>Ref:</p>
<ol>
<li>CPython设计与实现</li>
<li>Python源码深度剖析</li>
<li>CPython3.9源码</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/CPython/" class="print-no-link">#CPython</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CPython(2) - 内存管理与垃圾回收</div>
      <div>https://dinghanyang.github.io/dhy_blog/2024/10/13/cpython-memory/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Hanyang Ding</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年10月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/11/compile-cpython-in-macos/" title="CPython(1)-macOS下通过CLion编译CPython">
                        <span class="hidden-mobile">CPython(1)-macOS下通过CLion编译CPython</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      闽ICP备2020020012号-2
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
