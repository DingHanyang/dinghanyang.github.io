<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CPython(2) - 内存管理与垃圾回收</title>
    <link href="/2024/10/13/cpython-memory/"/>
    <url>/2024/10/13/cpython-memory/</url>
    
    <content type="html"><![CDATA[<h2 id="CPython的内存管理"><a href="#CPython的内存管理" class="headerlink" title="CPython的内存管理"></a>CPython的内存管理</h2><p>首先我们设想下，CPython是由C语言实现的，为什么他不直接使用C语言中的malloc系列函数，而要自己折腾一个内存管理呢？</p><p>在C中，有三种内存分配方式：</p><ul><li>静态内存分配（static memory allocation），编译期间即可计算所需分配内存大小，在可执行文件开始运行时分配。</li><li>自动内存分配（automatic memory allocation），当一个帧开始运行的时候，操作系统会在调用栈中为此作用域分配所需内存，当帧执行完成后，这部分内存会被释放。</li><li>动态内存分配（dynamic memory allocation），可以通过调用内存分配API在运行时动态地请求和分配内存。</li></ul><p>考虑这个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the size of the array: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-comment">// Dynamically allocate memory for the array</span><br>    <span class="hljs-type">int</span> *<span class="hljs-built_in">array</span> = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-comment">// Free the allocated memory</span><br>    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">array</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述程序运行时，系统并不清楚需要分配具体多大的内存，直到接收到用户输入后，通过C API动态分配内存。<br>由于Python是一门动态类型的语言，大多数内建类型大小都是可以动态调整的，比如<code>List</code>可以是任意长度，<code>Dict</code>键的数量可以动态变化，所以<strong>动态内存分配</strong>在Python中显得尤为重要。<br>而频繁的进行内存的分配与释放会严重影响程序的效率，并且可能造成大量的<strong>内存碎片</strong>。为了解决这些问题，Python自己设计了一套内存管理方案，包含了<strong>内存池、引用计数法、垃圾回收算法等</strong>内容。</p><h3 id="CPython的内存分配域"><a href="#CPython的内存分配域" class="headerlink" title="CPython的内存分配域"></a>CPython的内存分配域</h3><ul><li>Raw Domain 原始内存分配域：用于从系统堆上分配内存，作用于大块或非对象的内存分配。</li><li>Object Domain 对象内存分配域：用于所有Python对象的内存分配。</li><li>Mem Domain PyMem 内存分配域：和PYMEM_DOMAIN_OBJ对象功能一致，用于支持旧版本API。</li></ul><h3 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h3><p>CPython使用两种内存分配器：</p><ul><li>malloc，操作系统层面的内存分配器，主要用于原始内存的分配。</li><li>pymalloc，CPython层面的内存分配器，用于PyMem内存分配域和对象内存分配域。</li></ul><p>由于Python中大部分需要分配的内存都是碎片化且是固定大小的，比如<code>PyObject</code>占16字节、<code>PyLongObject</code>占32字节。在这种情况下，内存碎片的产生概率是非常大的，所以CPython设计将需要分配的内存按大小进行统一管理。其中：</p><ul><li>对象大于等于256KB，将会由系统内存分配管理。</li><li>对象小于256KB，将会由pymalloc进行分配。</li></ul><h3 id="内存块、内存池与堆区"><a href="#内存块、内存池与堆区" class="headerlink" title="内存块、内存池与堆区"></a>内存块、内存池与堆区</h3><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>堆区是最大的可分配内存单元。系统页的边界是固定长度的连续内存块，为了与系统页的大小对齐，CPython中创建的堆区大小固定为256KB。</p><img src="/2024/10/13/cpython-memory/.."  alt="堆区表示" style="zoom:80%;" /><p>与堆区对应的是<strong>arena_object</strong></p><h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p>在堆区中，我们可以为最大为512字节的内存块创建内存池。每个内存池的大小为4096字节，也就是4K，一个堆区中总是存在64个内存池。</p><p><img src="/./../img/cpython-memory/%E5%86%85%E5%AD%98%E6%B1%A0%E8%A1%A8%E7%A4%BA.png" alt="内存池表示"><br>根据32位系统和64位系统的不同，内存块的步长也不同，对于32位系统，步长为8字节，总共有64种不同的内存块。</p><table><thead><tr><th align="center">以字节为单位请求申请内存</th><th align="center">分配内存块的大小</th><th align="center">内存大小索引</th></tr></thead><tbody><tr><td align="center">1-8</td><td align="center">8</td><td align="center">0</td></tr><tr><td align="center">9-16</td><td align="center">16</td><td align="center">1</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">505-512</td><td align="center">512</td><td align="center">63</td></tr></tbody></table><p>以32位系统为例，只要请求的内存大小不超过 <em>8</em> 字节，<em>Python</em> 都在这个内存池为其分配一块 <em>8</em> 字节内存，就算只申请 1 字节内存也是如此。这种做法好处显而易见，内存起始地址均以计算机字为单位对齐。计算机以 <strong>字</strong> ( <em>word</em> ) 为单位访问内存，因此内存以字对齐可提升内存读写速度。<br>CPython会根据内存请求的大小分配内存池，当没有可以用的内存池用于请求的内存大小索引时，就可以分配一个新的内存池。堆区中有一个概念叫<strong>高水位线</strong>，可以用于查询当前已经分配的内存池数量。内存池存在三种状态：</p><ul><li><strong>满载</strong>，所有可用内存块均已被分配，可以暂时不管。</li><li><strong>部分使用</strong>，已经有部分内存被分配，但还存在空闲内存，会以双向链表的方式组织起来。</li><li><strong>空闲</strong>，内存池被分配，但内存池中的内存块均未被使用，待使用或归还。</li></ul><p>三种状态决定了CPython对其的管理方式。</p><p>[^A1]: 在创建堆（arena）时，CPython并不会一次性为所有大小类别的内存池都分配内存，而是根据实际需求逐步进行分配。例如，当需要一个 32 字节大小的对象时，Python会检查是否有合适的内存池，如果没有则创建一个用于存储 32 字节大小的内存块的内存池。另外，虽然每个内存池的总大小固定为4 KB，但因为每个池中内存块的大小不同，导致每个内存池内包含的内存块数量是不同的。</p><h4 id="内存池表"><a href="#内存池表" class="headerlink" title="内存池表"></a>内存池表</h4><p>在堆区中，内存池的存储单元名为<strong>内存池表</strong>，pool table记录了被部分使用的内存池的双向链表头节点。内存池表根据内存池的内存大小索引<code>i</code>进行分类。对于内存大小索引<code>i</code>，<code>usedpools[i + 1]</code>会指向所有被部分使用的内存池的双向链表头节点，链表中的内存池都拥有相同的类型大小。</p><ul><li>当一个内存池饱和后，它就会被<code>usedpools[]</code>解除链接。</li><li>如果已经饱和的内存池中有一个内存块被释放了，那么内存池就将重新回到部分使用的状态。此时还会帮刚刚释放内存的内存池重新连接到<code>usepools[]</code>中链表的前面，这样在下次分配同样大小的内存时将复用刚刚释放的内存块。</li><li>当一个内存池变为全空时，这个内存池同样也会从<code>usedpools[]</code>中被移除，然后被链接到它所在的堆区的单向链表的<code>freepools</code>的前面。</li></ul><h4 id="内存块"><a href="#内存块" class="headerlink" title="内存块"></a>内存块</h4><p>内存块也是同样的，在一个内存池中有存在多个内存块，数量根据内存块的大小而有所不同，比如一个管理8字节的内存池中存在4096&#x2F;8 &#x3D; 512个内存块。而管理512字节内存块的内存池中仅有8个内存块。</p><ul><li>在一个内存池中，可以分配和释放固定内存大小索引的内存块。</li><li>所有可用的内存块都会被链接到<code>freeblock</code>链表上。</li><li>当一个内存块被释放后，他会被插入到<code>freeblock</code>的头部。</li><li>当一个内存池被初始化时，只有最前面两个内存块会被链接到<code>freeblock</code>，因为接收到申请，才初始化内存池，并不存在创建内存池等分配的情况，并且下一个内存块的地址可以通过上一个内存块计算出来。</li><li>如果一个内存池处于被部分使用的状态，那么这个内存池里面至少有一个内存块用于内存分配。</li></ul><h2 id="CPython的垃圾内收"><a href="#CPython的垃圾内收" class="headerlink" title="CPython的垃圾内收"></a>CPython的垃圾内收</h2><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数真的是最简单及常见的垃圾回收方法之一了。CPython通过维护内部对象的引用次数，将没有被引用的对象回收以释放内存。每一个PyObject实例对象都有一个<code>ob_refcnt</code>属性来记录引用数量，且CPython通过<code>Py_INCREF</code>和<code>Py_DECREF</code>来控制引用计数属性的增减。在<code>Include/object.h</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> _Py_INCREF(PyObject *op)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> Py_REF_DEBUG</span><br>    _Py_RefTotal++;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    op-&gt;ob_refcnt++;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Py_INCREF(op) _Py_INCREF(_PyObject_CAST(op))</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> _Py_DECREF(<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> Py_REF_DEBUG</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> lineno,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    PyObject *op)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> Py_REF_DEBUG</span><br>    _Py_RefTotal--;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (--op-&gt;ob_refcnt != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> Py_REF_DEBUG</span><br>        <span class="hljs-keyword">if</span> (op-&gt;ob_refcnt &lt; <span class="hljs-number">0</span>) &#123;<br>            _Py_NegativeRefcount(filename, lineno, op);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        _Py_Dealloc(op);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>Py_INCREF</code>的定义是简单的，只需控制引用计数属性的自增，<code>Py_DECREF</code>还需要处理当引用计数为0后的触发析构函数的操作。<br>一般来说Python的开发者几乎无法控制引用计数的操作，因为他都发生在CPython字节码中。但是引用计数最大的问题是会产生循环引用，比如在Python代码中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = []<br>a.append(a)<br><span class="hljs-keyword">del</span> a<br></code></pre></td></tr></table></figure><p>此时由于a引用了自己，所以即使在del操作后，a的引用计数也会为1。为了解决此类问题，Python还引入了垃圾回收。</p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>由于Python中充斥着大量的容器类型，如列表、元组、字典、集合等，在开发者的操作下很容易造成循环引用且生成大量<strong>不可达对象</strong>而垃圾回收算法的主要目的就是找到这些不可达对象且将他们回收。对于长期运行的程序来说，这是非常重要的一个操作。垃圾回收器只会查找在类型定义中设置了<code>Py_TPFLAGS_HAVE_GC</code>标志的类型。以下是在Python3.9.12中被标记为需要垃圾回收的类型：</p><ul><li>类、方法、函数对象</li><li>cell对象</li><li>字节数组、单字节、Unicode字符串</li><li>字典</li><li>属性中的描述符对象</li><li>枚举对象</li><li>异常</li><li>帧对象</li><li>列表、元组、命名元组和集合</li><li>内存对象</li><li>模块和命名空间</li><li>类型和弱引用对象</li><li>迭代器和生成器</li><li>pickle缓存区</li></ul><p>诸如浮点数类型、整型、布尔类型、NoneType都不会被标记。当然如果自己编写Python的C语言拓展模块，也可以按需增加标记，从而使得CPython的垃圾回收机制能够追踪。</p><p>其中垃圾回收机制还创造了一种取消追踪的机制，由于元组是不可变对象，所以他一旦被创建，就不会改变，但是元组中可以包含可变类型。所以当垃圾回收器运行的时候，每一个元组都会检查自己是否只包含不可变（或者不需要追踪）对象，如果只包含不可变对象的话，元组就会申请取消对自己的追踪，从而减少垃圾回收器的开销。</p><p>当我们创建空字典时，他虽然是可变对象，但是在未往其中添加数据时，垃圾回收器并不会追踪他们，可以通过<code>gc</code>模块中的gc.is_tracked(obj)来查看一个对象是否被追踪。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">import</span> <span class="hljs-variable">gc</span><br><span class="hljs-variable">a</span> = <span class="hljs-function"><span class="hljs-title">dict</span>()</span><br><span class="hljs-variable">gc.is_tracked</span>(<span class="hljs-variable">a</span>)<br>&gt;&gt;&gt;<span class="hljs-variable"><span class="hljs-literal">False</span></span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE]</p><p><a href="https://github.com/python/cpython/issues/48324">https://github.com/python/cpython/issues/48324</a></p><p><a href="https://github.com/python/cpython/issues/48938">https://github.com/python/cpython/issues/48938</a></p><p>2008年，为了解决创造a list of tuples中大量空元组使得gc性能下降明显而做的优化。</p><p>此处有一个较为疑惑的点是，为什么在Python3.1中，减少了对新建的空字典的GC追踪而不取消对新建的空列表的追踪呢？当然字典这个结构在Python层面是非常重要的，对性能的影响也是巨大，但这不意味改变对新建空List的追踪不会带来性能上的提升，挖个坑补全下这个的历史原因及相关的实验。</p></blockquote><h5 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h5><p><em>Python</em> 程序启动后，内部可能会创建大量对象。如果每次执行标记清除法时，都需要遍历所有对象，多半会影响程序性能。为此，<em>Python</em> 引入分代回收机制——将对象分为若干“<strong>代</strong>”( <em>generation</em> )，每次只处理某个代中的对象，因此 <em>GC</em> 卡顿时间更短。</p><p>考察对象的生命周期，可以发现一个显著特征：一个对象存活的时间越长，它下一刻被释放的概率就越低。我们应该也有这样的亲身体会：经常在程序中创建一些临时对象，用完即刻释放；而定义为全局变量的对象则极少释放。</p><p>因此，根据对象存活时间，对它们进行划分就是一个不错的选择。对象存活时间越长，它们被释放的概率越低，可以适当降低回收频率；相反，对象存活时间越短，它们被释放的概率越高，可以适当提高回收频率。</p><table><thead><tr><th align="center">对象存活的时间</th><th>释放的概率</th><th align="center">GC检查的频率</th></tr></thead><tbody><tr><td align="center">长</td><td>低</td><td align="center">低</td></tr><tr><td align="center">短</td><td>高</td><td align="center">高</td></tr></tbody></table><p><em>Python</em> 内部根据对象存活时间，将对象分为 <em>3</em> 代。</p><p>每个代都由一个 <em>gc_generation</em> 结构体来维护，定义于 <em>Include&#x2F;internal&#x2F;pycore_gc.h</em> 头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gc_generation</span> &#123;</span><br>    PyGC_Head head;<br>    <span class="hljs-type">int</span> threshold; <span class="hljs-comment">/* collection threshold */</span><br>    <span class="hljs-type">int</span> count; <span class="hljs-comment">/* count of allocations or collections of younger</span><br><span class="hljs-comment">                  generations */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>head ，可收集对象链表头部，代中的对象通过该链表维护；</li><li>threshold ，仅当 <em>count</em> 超过本阀值时，<em>Python</em> 垃圾回收操作才会扫描本代对象；</li><li>count ，计数器，不同代统计项目不一样；</li></ul><p>每个 <em>gc_generation</em> 结构体链表头节点都指向自己，换句话说每个可收集对象链表一开始都是空的；计数器字段 <em>count</em> 都被初始化为 <em>0</em> ；而阀值字段 <em>threshold</em> 则有各自的策略。</p><img src="/2024/10/13/cpython-memory/gc_generation (1).png"  alt="gc_generation (1)" style="zoom:67%;" /><p><em>Python</em> 调用 <em>_PyObject_GC_Alloc</em> 为需要跟踪的对象分配内存时，该函数将初生代 <em>count</em> 计数器加一，随后对象将接入初生代对象链表；当 <em>Python</em> 调用 <em>PyObject_GC_Del</em> 释放垃圾对象内存时，该函数将初生代 <em>count</em> 计数器减一；*_PyObject_GC_Alloc* 自增 <em>count</em> 后如果超过阀值( <em>700</em> )，将调用 <em>collect_generations</em> 执行一次垃圾回收( <em>GC</em> )。</p><p><em>collect_generations</em> 函数从老生代开始，逐个遍历每个生代，找出需要执行回收操作( <em>count&gt;threshold</em> )的最老生代。随后调用 <em>collect_with_callback</em> 函数开始回收该生代，而该函数最终调用 <em>collect</em> 函数。</p><p><em>collect</em> 函数处理某个生代时，先将比它年轻的生代计数器 count 重置为 <em>0</em> ；然后将它们的对象链表移除，与自己的拼接在一起后执行 <em>GC</em> 算法；最后，将下一个生代计数器加一。</p><ul><li>系统每新增 <em>701</em> 个需要 <em>GC</em> 的对象，<em>Python</em> 就执行一次 <em>GC</em> 操作；</li><li>每次 <em>GC</em> 操作需要处理的生代可能是不同的，由 <em>count</em> 和 <em>threshold</em> 共同决定；</li><li>某个生代需要执行 <em>GC</em> ( <em>count&gt;threshold</em> )，在它前面的所有年轻生代也同时执行 <em>GC</em> ；</li><li>对多个代执行 <em>GC</em> ，<em>Python</em> 将它们的对象链表拼接在一起，一次性处理；</li><li><em>GC</em> 执行完毕后，<em>count</em> 清零，而后一个生代 <em>count</em> 加一；</li></ul><p>初生代触发 <em>GC</em> 操作，<em>Python</em> 执行 <em>collect_generations</em> 函数。它找出了达到阀值的最老生代是中生代，因此调用 <em>collection_with_callback(1)</em> ，<em>1</em> 是中生代在数组中的下标。</p><p><em>collection_with_callback(1)</em> 最终执调用 <em>collect(1)</em> ，它先将后一个生代计数器加一；然后将本生代以及前面所有年轻生代计数器重置为零；最后调用 <em>gc_list_merge</em> 把可回收对象链表合并在一起。</p><ul><li>每新增 <em>701</em> 个需要 <em>GC</em> 的对象，触发一次新生代 <em>GC</em> ；</li><li>每执行 <em>11</em> 次新生代 <em>GC</em> ，触发一次中生代 <em>GC</em> ；</li><li>每执行 <em>11</em> 次中生代 <em>GC</em> ，触发一次老生代 <em>GC</em> (老生代 <em>GC</em> 还受其他策略影响，频率更低)；</li><li>执行某个生代 <em>GC</em> 前，年轻生代对象链表也移入该代，一起 <em>GC</em> ；</li><li>一个对象创建后，随着时间推移将被逐步移入老生代，回收频率逐渐降低；</li></ul><h5 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h5><p><em>Python</em> 采用标记清除法识别垃圾对象。该算法的输入是可收集对象链表，链表给出所有需要检测的对象；算法的输出是两个链表，其中一个包含 <strong>可达</strong> ( <em>reachable</em> )对象，另一个包含 <strong>不可达</strong> ( <em>unreachable</em> )对象。</p><p>标记清除算法在 <em>collect</em> 函数中实现，它位于 <em>Modules&#x2F;gcmodule.c</em> ，步骤并不复杂。为避免深陷源码细节，我们先抽出身来进行一次直观考察。假设待检测可收集对象链表中的对象引用关系如下：</p><img src="/2024/10/13/cpython-memory/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" class="" title="循环引用"><p>其中，数字表示引用计数，箭头表示引用关系，虚线表示链表外对象(来自其他年代)，</p><p>首先，我们需要找出根对象。这里根对象是指被本链表以外的对象引用或被 <em>Python</em> 虚拟机直接引用的对象，与上一小节讨论的略有不同。由于根对象存在来自外部的引用，不能安全释放，应该标记为 <strong>可达</strong> ( <em>reachable</em> )。</p><p>根对象集合不难确定：我们只需遍历每个对象引用的对象，将它们的引用计数减一，最后计数不为零的就是根对象。</p><img src="/2024/10/13/cpython-memory/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A82%20(2).png" class="" title="循环引用2 (2)"><p>请注意，虚线表示外部对象，它既不会被遍历到，引用计数也不会被减一。然后从根节点对象出发，将所有不可达的节点标记为不可达节点，如最左边图中的三个对象均为不可达对象。这样一来，他们就是只存在循环引用的垃圾对象，可以被安全释放。</p><p>对于<em>collect</em> 函数的算法处理逻辑，它先将对象引用计数拷贝到 <em>gc_refs</em> 字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">update_refs(young);<br></code></pre></td></tr></table></figure><p>这是因为直接操作 <em>ob_refcnt</em> 字段的话，对象的引用计数就被破坏了，而且无法复原。操作 <em>gc_refs</em> 副本字段，就不存在这个问题。</p><p>接着，<em>collect</em> 函数调用 <em>subtract_refs</em> 遍历链表中每个对象，将它们引用的对象引用计数( <em>gc_refs</em> )减一。注意到，<em>subtract_refs</em> 函数调用 <em>tp_traverse</em> 函数，来遍历被一个对象引用的对象：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">subtract_refs</span>(young);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">visit_decref</span><span class="hljs-params">(PyObject *op, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    assert(op != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (PyObject_IS_GC(op)) &#123;<br>        PyGC_Head *gc = AS_GC(op);<br>        assert(_PyGCHead_REFS(gc) != <span class="hljs-number">0</span>); <span class="hljs-comment">/* else refcount was too small */</span><br>        <span class="hljs-keyword">if</span> (_PyGCHead_REFS(gc) &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 将对象引用计数减一(gc_refs)</span><br>            _PyGCHead_DECREF(gc);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">subtract_refs</span><span class="hljs-params">(PyGC_Head *containers)</span><br>&#123;<br>    traverseproc traverse;<br>    PyGC_Head *gc = containers-&gt;gc.gc_next;<br>    <span class="hljs-comment">// 遍历链表每一个对象</span><br>    <span class="hljs-keyword">for</span> (; gc != containers; gc=gc-&gt;gc.gc_next) &#123;<br>        <span class="hljs-comment">// 遍历当前对象所引用的对象，调用visit_decref将它们的引用计数减一</span><br>        traverse = Py_TYPE(FROM_GC(gc))-&gt;tp_traverse;<br>        (<span class="hljs-type">void</span>) traverse(FROM_GC(gc),<br>                       (visitproc)visit_decref,<br>                       <span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过这个步骤之后，根对象就被找出来了，它们的引用计数( <em>gc_refs</em> )不为零。</p><p>最后，<em>collect</em> 函数初始化一个链表 <em>unreachable</em> 来保存不可达对象，调用 <em>move_unreachable</em> 标记可达对象，并将不可达对象移入 <em>unreachable</em> 链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">gc_list_init(&amp;unreachable);<br>move_unreachable(young, &amp;unreachable);<br></code></pre></td></tr></table></figure><p><em>move_unreachable</em> 遍历给定对象链表，如果一个对象的引用计数不为 <em>0</em> ，就将它标记为可达( <em>GC_REACHABLE</em> )；否则将它标记为临时不可达，移入不可达链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 遍历链表每个对象</span><br><span class="hljs-keyword">while</span> (gc != young) &#123;<br>    PyGC_Head *next;<br><br>    <span class="hljs-comment">// 如果引用计数不为0，说明它可达</span><br>    <span class="hljs-keyword">if</span> (_PyGCHead_REFS(gc)) &#123;<br>        PyObject *op = FROM_GC(gc);<br>        traverseproc traverse = Py_TYPE(op)-&gt;tp_traverse;<br>        assert(_PyGCHead_REFS(gc) &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将它标记为可达</span><br>        _PyGCHead_SET_REFS(gc, GC_REACHABLE);<br>        <span class="hljs-comment">// 遍历被它引用的对象，调用visit_reachable将被引用对象标记为可达</span><br>        (<span class="hljs-type">void</span>) traverse(op,<br>                        (visitproc)visit_reachable,<br>                        (<span class="hljs-type">void</span> *)young);<br>        next = gc-&gt;gc.gc_next;<br>        <span class="hljs-keyword">if</span> (PyTuple_CheckExact(op)) &#123;<br>            _PyTuple_MaybeUntrack(op);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        next = gc-&gt;gc.gc_next;<br>        <span class="hljs-comment">// 暂时移入不可达链表</span><br>        gc_list_move(gc, unreachable);<br>        _PyGCHead_SET_REFS(gc, GC_TENTATIVELY_UNREACHABLE);<br>    &#125;<br>    gc = next;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个对象可达，<em>Python</em> 还通过 <em>tp_traverse</em> 逐个遍历它引用的对象，并调用 <em>visit_reachable</em> 函数进行标记：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">visit_reachable</span><span class="hljs-params">(PyObject *op, PyGC_Head *reachable)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (PyObject_IS_GC(op)) &#123;<br>        PyGC_Head *gc = AS_GC(op);<br>        <span class="hljs-type">const</span> Py_ssize_t gc_refs = _PyGCHead_REFS(gc);<br><br>        <span class="hljs-keyword">if</span> (gc_refs == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 引用计数为零，将计数设置为1，表明它是可达的</span><br>            _PyGCHead_SET_REFS(gc, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gc_refs == GC_TENTATIVELY_UNREACHABLE) &#123;<br>            <span class="hljs-comment">// 如果对象被临时标记为不可达，将引用计数设置为1表明它是可达的</span><br>            <span class="hljs-comment">// 并移回原链表继续处理</span><br>            gc_list_move(gc, reachable);<br>            _PyGCHead_SET_REFS(gc, <span class="hljs-number">1</span>);<br>        &#125;<br>         <span class="hljs-keyword">else</span> &#123;<br>            assert(gc_refs &gt; <span class="hljs-number">0</span><br>                   || gc_refs == GC_REACHABLE<br>                   || gc_refs == GC_UNTRACKED);<br>         &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果被引用的对象引用计数为 <em>0</em> ，将它的引用计数设为 <em>1</em> ，之后它将被 <em>move_unreachable</em> 遍历到并设为可达；如果被引用的对象被临时移入 <em>unreachable</em> 链表，同样将它的引用计数设为 <em>1</em> ，并从 <em>unreachable</em> 链表移回原链表尾部，之后它将被 <em>move_unreachable</em> 遍历到并设为可达。</p><p>当 <em>move_unreachable</em> 函数执行完毕，<em>unreachable</em> 链表中的对象就是不可达对象，可被安全回收。</p><p>Ref:</p><ol><li>CPython设计与实现</li><li>Python源码深度剖析</li><li>CPython3.9源码</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CPython</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPython(1)-macOS下通过CLion编译CPython</title>
    <link href="/2024/10/11/compile-cpython-in-macos/"/>
    <url>/2024/10/11/compile-cpython-in-macos/</url>
    
    <content type="html"><![CDATA[<p>由于这段时间手头没有Windows平台的电脑，而且又习惯了JB家的IDE产品。研究了一下如何在CLion中编译并调试CPython。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>macOS：15.1</li><li>CLion：2024.2.2 (版本必须大于2020.2)</li></ul><h3 id="安装C语言编译器和工具包"><a href="#安装C语言编译器和工具包" class="headerlink" title="安装C语言编译器和工具包"></a>安装C语言编译器和工具包</h3><p><code>$ xcode-select --install</code></p><p>会安装 Xcode 命令行工具（Command Line Tools for Xcode），这些工具包含了一系列用于开发的命令行程序和库，比如编译器（clang、gcc 等）、调试器（lldb）、各种开发相关的脚本和工具等。</p><h3 id="安装OpenSSL"><a href="#安装OpenSSL" class="headerlink" title="安装OpenSSL"></a>安装OpenSSL</h3><p>从PyPI官网获取包的时候，需要OpenSSL，一般来说构建完成后会获取其他包，我们可以通过Homebrew安装：</p><p><code> $brew install openssl xz zlib gdbm sqlite</code></p><h3 id="获取cpython源码"><a href="#获取cpython源码" class="headerlink" title="获取cpython源码"></a>获取cpython源码</h3><p>可以通过 <a href="https://www.python.org/">python官网</a>或者直接通过github获得，我这边使用的是3.13：</p><p><code>$ git clone --branch 3.13 https://github.com/python/cpython</code></p><h3 id="生成makefile"><a href="#生成makefile" class="headerlink" title="生成makefile"></a>生成makefile</h3><p>获得cpython源码后，进入到文件夹根目录下，运行</p><p><code>$ CPPFLAGS=&#39;-I$(brew --prefix zlib)/include&#39;</code></p><p><code>$ LDFLAGS=&#39;-L$(brew --prefix zlib)/lib&#39;</code></p><p>先设置环境变量指定zlib的位置，然后生成makefile文件。</p><p><code>$ ./configure</code></p><img src="/2024/10/11/compile-cpython-in-macos/image-20241011162516802.png"  alt="image-20241011162516802"  /><p>将会在当前目录下生成<code>makefile</code>文件。</p><p>接下来可以使用</p><p><code>$ make -j4 -s</code></p><p>生成<code>python.exe</code>，很神奇的是在macOS下，生成的居然是.exe，不过这不是Windows可执行文件，因为macOS文件系统不区分大小写，为了防止意外引用<code>Python/</code>而故意设置的。</p><h3 id="CLion配置"><a href="#CLion配置" class="headerlink" title="CLion配置"></a>CLion配置</h3><p>生成<code>makefile</code>文件结束后即可通过CLion打开。</p><p>在CLion中选择Open-&gt;选择cpython目录下的<code>makefile</code>文件-&gt;open as project</p><img src="/2024/10/11/compile-cpython-in-macos/image-20241011164201266.png"  alt="image-20241011164201266"  /><p>使用默认值<code>clean</code></p><img src="/2024/10/11/compile-cpython-in-macos/image-20241011164235165.png"  alt="image-20241011164235165"  /><p>在上方菜单栏中选择build-&gt;build project就会开始构建python</p><img src="/2024/10/11/compile-cpython-in-macos/image-20241011164544264.png"  alt="image-20241011164544264"  /><p>接下来设置已编译的二进制文件为运行&#x2F;调试的配置选项。</p><p>在上方菜单栏选择Run-&gt;Edit Configurations。</p><p>在Native Application中按图中参数设置：</p><img src="/2024/10/11/compile-cpython-in-macos/image-20241011165222344.png"  alt="image-20241011165222344"  /><img src="/2024/10/11/compile-cpython-in-macos/image-20241011165308838.png"  alt="image-20241011165308838"  /><p>配置完成后即可在CLion中通过右上角快捷栏运行我们的REPL:</p><img src="/2024/10/11/compile-cpython-in-macos/image-20241011165419333.png" class="" title="image-20241011165419333"><p>如果在CPython中设置了任何断点的话，使用DEBUG模式运行即可。</p><h3 id="Refs"><a href="#Refs" class="headerlink" title="Refs:"></a>Refs:</h3><ul><li>《CPython》设计与实现</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CPython</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[思考]-李沐讲座：大语言模型的实践经验和未来预测</title>
    <link href="/2024/08/30/LLM-speech-from-Mu-Li/"/>
    <url>/2024/08/30/LLM-speech-from-Mu-Li/</url>
    
    <content type="html"><![CDATA[<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>带宽的重要性高，机房、机架、芯片的密集程度、摆放的位置会产生延迟，延迟会对计算速度产生很大的影响。</li><li>内存的大小目前受到工艺和技术的限制，未来比较长的一段时间可能会在200GB以内，也就是说其实模型大小在未来一段时间中会被控制在一定的范围内，而不是由于算力的限制导致模型大小无法扩展。</li><li>算力</li><li>供电，李沐老师提到曾经花几个月去调研发现，自己造一个电厂的成本比用电还低。</li><li>硬件的价格，长期来看算力会越来越便宜，在自由竞争的市场中，算力翻倍的情况下，算力的价格应该维持不变。</li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><img src="/2024/08/30/LLM-speech-from-Mu-Li/image-20240830220159597.png" class="" title="PPT"><ul><li><p>Token的数量级不会有显著提升</p></li><li><p>模型大小在100-500B</p></li><li><p>音乐的生成</p></li><li><p>语言交互的延迟降低了</p></li><li><p>图片逐渐的有”灵魂”，缺少了一下情绪的表达</p></li><li><p>视频的生成，视频的数据处理的成本很可能高于视频生成模型生成的一个成本</p></li><li><p>多模态能借用文本模型的泛化能力去支持其他模态，自然语言交互可能是未来的一个常态。能用清晰，有条理的语言去组织和表达自己想做的事情是一个很重要的能力。</p></li><li><p>Killer app概念，短视频是最近的一个Killer app</p></li><li><table><thead><tr><th align="center"></th><th align="center">简单任务</th><th align="center">复杂任务</th></tr></thead><tbody><tr><td align="center">文科白领</td><td align="center">✅</td><td align="center">🏗️</td></tr><tr><td align="center">理科白领</td><td align="center">🏗️</td><td align="center">Moonshot</td></tr><tr><td align="center">蓝领</td><td align="center">Moonshot</td><td align="center">Moonshot</td></tr></tbody></table><p>目前的进展来看，很难解决蓝领的问题，而蓝领是这个世界上最主要的成员</p></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>预训练是一个工程问题</li><li>后训练中，高质量的数据和算法很重要</li><li>垂直模型可能是个伪命题，没有一个真正的垂直模型，垂直模型的通用能力也是很强的。</li><li>模型的评估是重要的一个部分，自然语言有一定的二义性，模型评估会带来bias问题。</li><li>算法决定模型下限，数据决定模型上限。</li></ul><img src="/2024/08/30/LLM-speech-from-Mu-Li/image-20240830225809655.png" class="" title="image-20240830225809655"><ul><li>自建服务器的价格其实和使用云服务器差不多</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>演讲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习之计算机网络篇</title>
    <link href="/2024/08/26/Network-notebook-for-interview/"/>
    <url>/2024/08/26/Network-notebook-for-interview/</url>
    
    <content type="html"><![CDATA[<h1 id="面试复习之计算机网络篇"><a href="#面试复习之计算机网络篇" class="headerlink" title="面试复习之计算机网络篇"></a>面试复习之计算机网络篇</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Towards Deconfounded Image-Text Matching with Causal Inference</title>
    <link href="/2024/01/29/Towards-Deconfounded-Image-Text-Matching-with-Causal-Inference/"/>
    <url>/2024/01/29/Towards-Deconfounded-Image-Text-Matching-with-Causal-Inference/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Make-An-Audio: Text-To-Audio Generation with Prompt-Enhanced Diffusion Models</title>
    <link href="/2023/12/10/Make-An-Audio-Text-To-Audio-Generation-with-Prompt-Enhanced-Diffusion-Models/"/>
    <url>/2023/12/10/Make-An-Audio-Text-To-Audio-Generation-with-Prompt-Enhanced-Diffusion-Models/</url>
    
    <content type="html"><![CDATA[<h2 id="Make-An-Audio"><a href="#Make-An-Audio" class="headerlink" title="Make-An-Audio"></a>Make-An-Audio</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>文章指出由于Text-Audio pair数据的匮乏及音频数据的复杂性（每秒16kHz的采样率下，有16000个数据点），导致在多模态生成任务重，文本到音效的合成进展有效。随后在文章中提出针对这两个问题的解决方法：</p><ol><li>Pseudo Prompt Enhancement: Distill-then-Reprogram</li><li>Spectrogram autoencoder</li></ol><p>随后将text-to-audio推广到任意模态到音频</p><h3 id="Pseudo-Prompt-Enhancement-Distill-then-Reprogram"><a href="#Pseudo-Prompt-Enhancement-Distill-then-Reprogram" class="headerlink" title="Pseudo Prompt Enhancement: Distill-then-Reprogram"></a>Pseudo Prompt Enhancement: Distill-then-Reprogram</h3><p><img src="/../img/Make-An-Audio-Text-To-Audio-Generation-with-Prompt-Enhanced-Diffusion-Models.assets/image-20231215011901118.png" alt="image-20231215011901118"></p><ul><li><p>Expert 1:<a href="https://dcase.community/documents/workshop2020/proceedings/DCASE2020Workshop_Xu_83.pdf"> A CRNN-GRU BASED REINFORCEMENT LEARNING APPROACH TO AUDIO CAPTIONING</a></p><p>给音频加字幕的</p></li><li><p>Expert 2: <a href="https://arxiv.org/pdf/2209.14275.pdf">AUDIO RETRIEVAL WITH WAVTEXT5K AND CLAP TRAINING</a></p><p>跨模态检索的</p></li><li><p>评委：<a href="https://arxiv.org/pdf/2206.04769.pdf">CLAP:clap: : LEARNING AUDIO CONCEPTS FROM NATURAL LANGUAGE SUPERVISION</a></p></li></ul><p>专家1给无标记音频打上标签，专家2通过生成的标签再到数据库里去找无标记的音频，这样就生成了两对结果</p><ul><li>真实音频 与 预测label</li><li>真是label 与 预测音频</li></ul><h3 id="评委选择"><a href="#评委选择" class="headerlink" title="评委选择"></a>评委选择</h3><p>选择CLAP分高的那个audio-text pair<br>CLAP可以同时做Audio-captioning和text-audio retrieval<br>**Tips:**这里这样做最重要的原因是作者希望能够这个text能够是自然语言，比如 先听见雨声再听见人声，通过这种数据增强的方式可以合成这两个具有先后时间关系的声音。</p><h3 id="Dynamic-Reprogramming（特殊的数据构造方式）"><a href="#Dynamic-Reprogramming（特殊的数据构造方式）" class="headerlink" title="Dynamic Reprogramming（特殊的数据构造方式）"></a>Dynamic Reprogramming（特殊的数据构造方式）</h3><p>For verb (denoted as v), we have {‘hearing’, ‘noticing’, ‘listening to’, ‘appearing’}; for adjective (denoted as a), we have {‘clear’, ‘noisy’, ‘close-up’, ‘weird’, ‘clean’}; for noun (denoted as n), we have {‘audio’, ‘sound’, ‘voice’}; for numeral&#x2F;quantifier (denoted as q), we have {‘a’, ‘the’, ‘some’};</p><ul><li>before v q a n of &amp;, X</li><li>X after v q a n of &amp;</li><li>etc.</li></ul><p>通过把前面专家模型标注的数据随机填充到模版中形成新的数据</p><p><strong>Tips:</strong><br>T2A任务和TTS任务不同的是，T2A任务中文本和音频不具有时间相关性，用这个方法主要是为了构造出丰富的包含<strong>时间先后顺序</strong>的音频描述。</p><h3 id="A-high-level-overview-of-Make-An-Audio"><a href="#A-high-level-overview-of-Make-An-Audio" class="headerlink" title="A high-level overview of Make-An-Audio"></a>A high-level overview of Make-An-Audio</h3><p><img src="/../img/Make-An-Audio-Text-To-Audio-Generation-with-Prompt-Enhanced-Diffusion-Models.assets/image-20231215011005727.png" alt="image-20231215011005727"></p><h3 id="Textual-Representation"><a href="#Textual-Representation" class="headerlink" title="Textual Representation"></a>Textual Representation</h3><p>文本表征部分作者尝试使用CLAP和T5(LLM)进行实验，结果发现能得到差不多的性能。</p><ul><li>CLAP: 通过文本和图片训练得到联合表征</li><li>LLM: 纯文本训练</li></ul><p><strong>Tips:</strong><br>由于CLAP无论是模型大小还是效率上都优于LLM，作者选择了使用CLAP。这里虽然作者没写，但是原因是因为任务中进行文本表征的数据被限定在一个狭小的空间中。并且CLAP作为前面专家标注模型的评委，有点自导自演的感觉了。</p><h3 id="Audio-Representation"><a href="#Audio-Representation" class="headerlink" title="Audio Representation"></a>Audio Representation</h3><p><a href="https://github.com/YuanGongND/ssast">SSAST: Self-Supervised Audio Spectrogram Transformer</a><br>没做改变 照搬结构<br>Tips: 把音频转化成频谱图再做表征的原因</p><ol><li>频谱图从人类视觉方面更加直观且去除了相位属性</li><li>之前的任务已经证明了text-to-image的成功，所以尝试用文字通过生成频谱图</li></ol><p>跟图像比较大的区别就是不具有旋转不变性，所以空间比图像来说小一些</p><h3 id="Generative-Latent-Diffusion"><a href="#Generative-Latent-Diffusion" class="headerlink" title="Generative Latent Diffusion"></a>Generative Latent Diffusion</h3><p>Diffusion<br>GAN: weak conditional 质量可以保证 主要是多样性<br>Latent diffusion:</p><p><img src="/../img/Make-An-Audio-Text-To-Audio-Generation-with-Prompt-Enhanced-Diffusion-Models.assets/image-20231215121409223.png" alt="image-20231215121409223"></p><p>这张图解释为什么在latent space上而不是pixel上做diffusion<br>传统的模型浪费了一些算力和容量在人类不可感知的细节，比如像素级别的差异是区别和不敏感的。在可感知的区域用diffusion，细节上用GAN去做强conditional的任务。<br>这篇文章是在频谱图上面做的，可以类比图像。</p><p>U-Net: 作为diffusion去噪器<br>通过文本嵌入为条件，使用U-Net经过扩散过程</p><p>任务中的训练损失和DDPM相同，即使U-Net的预测噪声与采样的随机噪声的均方差损失</p><h2 id="X-To-Audio-No-Modality-Left-Behind"><a href="#X-To-Audio-No-Modality-Left-Behind" class="headerlink" title="X-To-Audio: No Modality Left Behind"></a>X-To-Audio: No Modality Left Behind</h2><ol><li><p>Personalized Text-To-Audio Generation</p><p>思想来源于 stochastic differential editing 随机差分编辑</p><p>个性化的音频编辑，比如有一个鸟叫声的音频，想在鸟叫的背景中加入风声，先设定一个时间步$t_0$,总去噪步骤为$N$,然后原始数据中为$t_0 \times N$加入噪声，然后去噪。</p></li><li><p>Audio Inpainting</p><p>思想来源于图像修复工作LaMa</p><p>然后基于Wav2vec2.0 做了一个基于时间域遮盖的模型</p><p><img src="/../img/Make-An-Audio-Text-To-Audio-Generation-with-Prompt-Enhanced-Diffusion-Models.assets/image-20231215125757154.png" alt="image-20231215125757154"></p></li><li><p>Visual(Image&#x2F;Video)-to-Audio</p><p><img src="/../img/Make-An-Audio-Text-To-Audio-Generation-with-Prompt-Enhanced-Diffusion-Models.assets/image-20231215125953662.png" alt="image-20231215125953662"><br>这里用的是CLIP, CLIP是一个将文本和图像映射到同一个隐空间的模型，直接用CLIP输出的图像表征去代替Text Encoder</p><p>视频的话是平均抽4个帧，然后做时间维度的池化，这里有比较大的问题，比如抽不出关键帧</p></li></ol><h2 id="Make-an-audio2"><a href="#Make-an-audio2" class="headerlink" title="Make-an-audio2"></a>Make-an-audio2</h2><p><img src="/../img/Make-An-Audio-Text-To-Audio-Generation-with-Prompt-Enhanced-Diffusion-Models.assets/image-20231215133813441.png" alt="image-20231215133813441"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to Read a Paper</title>
    <link href="/2023/12/08/How-to-Read-a-Paper/"/>
    <url>/2023/12/08/How-to-Read-a-Paper/</url>
    
    <content type="html"><![CDATA[<h2 id="How-to-Read-a-Paper"><a href="#How-to-Read-a-Paper" class="headerlink" title="How to Read a Paper"></a>How to Read a Paper</h2><p><a href="https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf"><em>How to Read a Paper</em></a> 是<em>S. Keshav</em>教授写的一篇如何通过三步法来进行论文阅读的指南。K教授认为很多研究生和学者都缺乏学习如何高效阅读论文的方法，所以他将在这篇文章中介绍如何应用<em>Three-pass</em> 方法去高效阅读论文或者写一篇综述。</p><h3 id="The-first-pass"><a href="#The-first-pass" class="headerlink" title="The first pass"></a>The first pass</h3><p>进行10到15分钟的快读，包括</p><ol><li>仔细阅读标题、摘要、介绍</li><li>阅读section和sub-section headings，但忽略内容</li><li>阅读结论</li><li>瞥一眼引用列表，看看是否有那些文章是阅读过的</li></ol><p>当快读进行完后可以选择性的回答以下几个问题：</p><ol><li>这篇论文是什么类型的</li><li>有其他论文和它相关吗，有那些基础理论是解决这个问题的</li><li>论文的假设是否有效</li><li>这篇论文的主要贡献是什么</li><li>这篇论文写作得好吗</li></ol><p>经过这个阶段实际上是像通过快速的浏览来辨别这篇文章是否值得深入读，或者先标记一下，以后的研究是否会用上。另外，K教授提示，当你在写一篇论文的时候，你可以通过<em>First pass</em>中的流程去审阅你的文章是否可以表达清晰，是否可以引起读者和审稿人的兴趣。</p><h3 id="The-second-pass"><a href="#The-second-pass" class="headerlink" title="The second pass"></a>The second pass</h3><p>第二部分需要你更仔细的去读文章，但是可以跳过那些证明的内容，抓住重点，这部分可以会耗时1小时左右：</p><ol><li>仔细阅读图表，特别是图表的坐标轴、标记是否合理，这可以帮助我们区分这篇文章是否真的优秀。</li><li>记得去标记一下引用中没有阅读过的文章，在未来通过阅读这些文章可以更好的在该领域展开研究。</li></ol><p>K教授提出在经过这一部分的阅读后，应该可以总结文章的主要内容，并且大致知道通过什么方法证明。但是在这个部分也会遇到一部分问题，可能是基础知识不够、论文写作风格造成了一些迷惑，亦或是需要有很多前置知识。当遇到困难时有三个选择：</p><ol><li>放弃</li><li>暂时搁置，先学习前置知识</li><li>坚持进入第三部分</li></ol><h3 id="The-third-pass"><a href="#The-third-pass" class="headerlink" title="The third pass"></a>The third pass</h3><p>为了完全去理解Paper所传达的意图，你需要完全的<em>re-implement</em>这篇文章，做和作者一样的假设，用一样的方法做出一样的结果并比较。通过这个过程，也许会发现隐藏的一些错误或者人为的假设。</p><p>初学者完成这一部分可能需要4-5小时甚至更长的时间，但是如果能完成的话，对整个文章的理解、实验的细节、可能存在的问题以及对于未来的工作都很有帮助。</p><h3 id="Doing-a-literature-survey"><a href="#Doing-a-literature-survey" class="headerlink" title="Doing a literature survey"></a>Doing a literature survey</h3><p>K教授同时也简单的介绍了下如何写文献综述：</p><ol><li>通过搜索引擎找一些研究领域最新文章，如果能找到一篇综述的话，那可以基于综述进行接下来的任务</li><li>标记这个领域中频繁出现的名字，他们大概率是该领域专家，去寻找他们的个人网站，查看他们近期的文章</li><li>通过这些专家的文章确定你所研究方向的顶会名称，从而找到更多的论文进行阅读</li></ol><p>这篇文章是K教授15年以来的阅读论文和了解未知领域的简单方法论，可以从中学习模式并尝试应用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
